---
title: log2
---
import { Steps } from '@astrojs/starlight/components';

The `log2` package provides wide-event logging with tail sampling, so each operation emits one structured event enriched with timeline steps, errors, and request context.

Core Components:

- `Config`: Logger configuration (`Writer`, `Format`, `Level`, `ContextKeys`, `Sampler`, `MaxSteps`).
- `DefaultConfig`: Returns defaults for output format, level, max steps, and sampler settings.
- `Logger`: Wide-event logger instance.
- `New`: Creates a logger from `Config`.
- `SetDefault`: Replaces package-level default logger.
- `Start`: Starts an event (`log2.Start` and `(*Logger).Start`).
- `Event`: Mutable event object.
- `Event.Add`, `Event.Step`, `Event.Error`, `Event.Finish`: Event lifecycle methods.
- `TailSampler`: Sampling interface.
- `SamplingDecision`: Keep/drop decision with reason.
- `EventView`: Immutable event view for sampling.
- `DefaultTailSamplerConfig`: Config for default sampler.
- `KeepRule`: Rule definition for forced-keep sampling.
- `NewDefaultTailSampler`: Builds default rule-based sampler.
- `HTTPMiddlewareConfig`, `NewHTTPMiddleware`: HTTP middleware that creates one event per request.
- `WithEvent`, `EventFromContext`, `LogEventContextKey`: Context helpers.
- `ErrEventAlreadyFinished`: Returned when `Finish` is called more than once.

[Full package docs at pkg.go.dev](https://pkg.go.dev/github.com/platforma-dev/platforma/log2)

## Step-by-step guide

<Steps>

1. Create a logger

    ```go
    cfg := log2.DefaultConfig()
    cfg.Level = slog.LevelInfo
    logger := log2.New(cfg)
    log2.SetDefault(logger)
    ```

    `DefaultConfig` includes:

    - `Format: "json"`
    - Default tail sampler (keep errors, 5xx, slow events, and a random sample)
    - `MaxSteps: 100`

2. Start and enrich an event

    ```go
    ev := logger.Start(ctx, "auth_request", "component", "handler")
    ev.Add("userId", "u-123")
    ev.Step(slog.LevelInfo, "credentials_validated", "provider", "password")
    ```

    `Add` merges persistent attributes. `Step` appends timeline entries.

3. Record errors and finish

    ```go
    if err != nil {
        ev.Error(err, "stage", "db_lookup")
    }

    if finishErr := ev.Finish("status", 200); finishErr != nil {
        if errors.Is(finishErr, log2.ErrEventAlreadyFinished) {
            // finish was called twice
        }
    }
    ```

    `Finish` evaluates sampling using event status, duration, errors, and attributes.

4. Configure custom tail sampling rules

    ```go
    cfg := log2.DefaultConfig()
    cfg.Sampler = log2.NewDefaultTailSampler(log2.DefaultTailSamplerConfig{
        KeepRules: []log2.KeepRule{
            {Field: "attrs.feature", Op: "eq", Value: "change_password"},
            {Field: "queue", Op: "in", Value: []string{"billing", "emails"}},
            {Field: "vip", Op: "exists"},
            {Field: "security.risk", Op: "true"},
        },
        RandomKeepRate: 0.01,
    })
    logger := log2.New(cfg)
    ```

    Supported rule operators are `eq`, `in`, `exists`, and `true`.

5. Add HTTP middleware and use event from request context

    ```go
    logger := log2.New(log2.DefaultConfig())
    middleware := log2.NewHTTPMiddleware(logger, log2.HTTPMiddlewareConfig{
        EventName: "http_request",
        RouteAttr: "route",
    })

    mux := http.NewServeMux()
    mux.HandleFunc("/ping", func(w http.ResponseWriter, r *http.Request) {
        if ev, ok := log2.EventFromContext(r.Context()); ok {
            ev.Step(slog.LevelInfo, "handler_started", "path", r.URL.Path)
        }

        w.WriteHeader(http.StatusOK)
        _, _ = w.Write([]byte("pong"))
    })

    handler := middleware(mux)
    _ = handler
    ```

    Middleware stores the event in context using `WithEvent`, collects request/response metadata, and calls `Finish` automatically.

</Steps>

## Behavior notes

- `Finish` called twice returns `ErrEventAlreadyFinished`.
- Event log level is inferred:
  - `ERROR` for event errors or 5xx status.
  - `WARN` for 4xx status.
  - `INFO` otherwise.
- Status is inferred from `status`, `statusCode`, `response.status`, or `response.status` inside a `response` map.
- If steps exceed `MaxSteps`, extra steps are dropped and counted in `stepsDropped`.

## Integration with `log` context keys

`log2.Start` extracts known context values from the `log` package and includes them in event attributes when present:

- `traceId`
- `serviceName`
- `domainName`
- `startupTask`
- `userId`
- `workerId`

This allows `log2` events to align with existing `log` and `httpserver` context propagation.

## Complete example

```go
package main

import (
	"context"
	"errors"
	"log/slog"
	"net/http"
	"os"
	"time"

	"github.com/platforma-dev/platforma/log2"
)

func main() {
	cfg := log2.DefaultConfig()
	cfg.Writer = os.Stdout
	cfg.Level = slog.LevelInfo
	cfg.Sampler = log2.NewDefaultTailSampler(log2.DefaultTailSamplerConfig{
		SlowThreshold:  500 * time.Millisecond,
		RandomKeepRate: 0.02,
	})

	logger := log2.New(cfg)
	middleware := log2.NewHTTPMiddleware(logger, log2.HTTPMiddlewareConfig{})

	mux := http.NewServeMux()
	mux.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
		ev, ok := log2.EventFromContext(r.Context())
		if ok {
			ev.Step(slog.LevelInfo, "fetch_users_started")
			defer func() {
				if err := ev.Finish("status", http.StatusOK); err != nil && !errors.Is(err, log2.ErrEventAlreadyFinished) {
					// Handle finish error.
				}
			}()
		}

		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte(`{"users":[]}`))
	})

	server := &http.Server{
		Addr:    ":8080",
		Handler: middleware(mux),
	}

	_ = server.ListenAndServe()
	_ = server.Shutdown(context.Background())
}
```
